

>作者 ： ThinyuXia
>日期 ：2021-10-05



#### 题目

![](https://z3.ax1x.com/2021/10/05/4v1j8U.png)



#### 题解1(横向扫描法)

令LCP(S1,S2)为字符串S1和S2的最长公共前缀

则可以得出n子字符串的最长前缀：*LCP*(*S*1…*Sn*)=*LCP*(*LCP*(*LCP*(*S*1,*S*2),*S*3),…*Sn*)

从左向右比较两个相邻的字符串，不断更新最长公共前缀长度即可

🌰

![](https://z3.ax1x.com/2021/10/05/4v8W6g.md.png)



#### 代码

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0)
            return "";
        String ans = strs[0]; // 存储结果，默认第一个字符串为最长公共前缀
        for (int i = 1; i < strs.length; i++) {
            int minLen = Math.min(ans.length(), strs[i].length());
            int j = 0;
            for (; j < minLen; j++) {
                if (ans.charAt(j) != strs[i].charAt(j)) {
                    break;
                }
            }
            ans = ans.substring(0, j); //不断更新最长公共前缀
        }
        return ans;
    }
}
```



`时间复杂度` ：O(mn) m为字符串列表长度，n为字符串平均长度 

`空间复杂度` ：O(1) 


