

>作者 ： ThinyuXia
>日期 ：2021-10-05



#### 题目

![](https://z3.ax1x.com/2021/10/05/4v1j8U.png)



#### 题解1(横向扫描法)

令LCP(S1,S2)为字符串S1和S2的最长公共前缀

则可以得出n子字符串的最长前缀：*LCP*(*S*1…*Sn*)=*LCP*(*LCP*(*LCP*(*S*1,*S*2),*S*3),…*Sn*)

从左向右比较两个相邻的字符串，不断更新最长公共前缀长度即可

🌰

![](https://z3.ax1x.com/2021/10/05/4v8W6g.md.png)



#### 代码

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0)
            return "";
        String ans = strs[0]; // 存储结果，默认第一个字符串为最长公共前缀
        for (int i = 1; i < strs.length; i++) {
            int minLen = Math.min(ans.length(), strs[i].length());
            int j = 0;
            for (; j < minLen; j++) {
                if (ans.charAt(j) != strs[i].charAt(j)) {
                    break;
                }
            }
            ans = ans.substring(0, j); //不断更新最长公共前缀
        }
        return ans;
    }
}
```



`时间复杂度` ：O(mn) m为字符串列表长度，n为字符串平均长度 

`空间复杂度` ：O(1) 


#### 题解2(纵向扫描法)

在题解1中有一个缺陷就是在扫描到最长公共前缀时都会多遍历字符m次，m = sum(每个临时的ans - 最长公共前缀的字符长度)

纵向扫描法的思路就是将字符串数组中的字符纵向排列，然后开始遍历第一行的字符c = strs[0].charAt(i)

然后再遍历第二到第n行的字符串，判断每个字符串的相应位置是否等于 c 即可，这样就不会多遍历字符了

这种做法优于第一种做法

![官方图片](https://assets.leetcode-cn.com/solution-static/14/14_fig2.png)

#### 代码

```java
class Solution {
    public String longestCommonPrefix(String[] strs){
        if(strs == null || strs.length == 0) return "";
        for(int i = 0;i < strs[0].length();i ++){
            char c = strs[0].charAt(i); // 存储第一行的每个字符便于比较
            for(int j = 1;j < strs.length;j ++){
                //1. i == strs[j].length() i到达当前行末尾即该行的相应位置没有字符
                //2. strs[j].charAt(i) != c 当前行对应位置的字符和第一行的字符不想等
                //满足以上两种情况直接返回结果即可
                if(i == strs[j].length() || strs[j].charAt(i) != c)
                return strs[0].substring(0,i);
            }
        }
        return strs[0];
    }
}
```

`时间复杂度` ：O(mn) m是最长公共前缀字符串的长度，n是字符串数组的长度 

`空间复杂度` ：O(1) 
